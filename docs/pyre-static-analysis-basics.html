<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Basics · Pyre</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Overview"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Basics · Pyre"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pyre-check.org/index.html"/><meta property="og:description" content="## Overview"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/integrated_logo_light.png" alt="Pyre"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/installation.html" target="_self">Getting Started</a></li><li class="siteNavGroupActive"><a href="/docs/overview.html" target="_self">Documentation</a></li><li class=""><a href="https://github.com/facebook/pyre-check" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Pyre Static Analysis</span></h2></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Contents</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/installation.html">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/guided-tour.html">Guided Tour</a></li><li class="navListItem"><a class="navItem" href="/docs/configuration.html">Configuring Pyre</a></li><li class="navListItem"><a class="navItem" href="/docs/gradual-typing.html">Gradual Typing</a></li><li class="navListItem"><a class="navItem" href="/docs/error-suppression.html">Error Suppression</a></li><li class="navListItem"><a class="navItem" href="/docs/error-types.html">Error Types</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-integration.html">Editor Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/watchman-integration.html">Watchman Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/querying-pyre.html">Querying Pyre</a></li><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Pyre Static Analysis</h4><ul><li class="navListItem navListItemActive"><a class="navItem" href="/docs/pyre-static-analysis-basics.html">Basics</a></li><li class="navListItem"><a class="navItem" href="/docs/pyre-static-analysis-running.html">Running Pyre Static Analyzer</a></li><li class="navListItem"><a class="navItem" href="/docs/pyre-static-analysis-features.html">Feature Annotations</a></li><li class="navListItem"><a class="navItem" href="/docs/pyre-static-analysis-advanced.html">Advanced Topics</a></li><li class="navListItem"><a class="navItem" href="/docs/pyre-static-analysis-tips.html">Development Tips</a></li><li class="navListItem"><a class="navItem" href="/docs/static-analysis-post-processor.html">Static Analysis Processor</a></li></ul></div></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Basics</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h2>
<p>Pyre has applications beyond type checking python code; it can also run static
analysis to identify potential security issues. These security issues are
identified with what is called a <strong>Taint Analysis</strong>.</p>
<p>Note that references to &quot;Pyre&quot; throughout the Static Analysis section of the
documentation will usually be specifically referring to the Pyre Static
Analyzer.</p>
<h2><a class="anchor" aria-hidden="true" id="taint-analysis"></a><a href="#taint-analysis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Taint Analysis</h2>
<p><strong>Tainted data</strong> is data that must be treated carefully. The Pyre Static
Analyzer works by tracking flows of data from where they originate (sources) to
where they terminate in a dangerous location (sinks). For example, we might use
it to track flows where user-controllable request data flows into an <code>eval</code>
call, leading to a remote code execution vulnerability. This analysis is
made possible by user-created stubs which provide annotations on source code, as
well as Rules that define which sources are dangerous for which sinks. Pyre
comes with many pre-written stubs and rules for builtin and common python
libraries.</p>
<p>Pyre propagates taint as operations are performed on tainted data. For example,
if we start with a tainted integer and perform a number of operations on it, the
end results will still be tainted:</p>
<pre><code class="hljs css language-python">x = some_function_that_returns_a_tainted_value() <span class="hljs-comment"># 'x' is marked as tainted</span>
y = x + <span class="hljs-number">10</span>
s = str(x)
f = <span class="hljs-string">f"Value = <span class="hljs-subst">{s}</span>"</span> <span class="hljs-comment"># 'f' is marked with the same taint 'x' had</span>
</code></pre>
<p>Pyre will only analyze the code in the repo that it runs on, as well as code in
directories listed in the <code>search_path</code> of your
<a href="/docs/configuration.html"><code>.pyre_configuration</code></a> file. It does not see the source of
your dependencies. <strong>Just because</strong> <strong><em>you</em></strong> <strong>can see code in your editor, it
does not mean Pyre has access to that code during analysis.</strong> Because of this
limitation, Pyre makes some simplifying assumptions during static analysis. If
taint flows into a function Pyre doesn't have the source for, it will assume
that the return type of that function has the same taint. This helps prevents
false negatives, but can also lead to false positives.</p>
<p>When an object is tainted, that means that all attributes of that object are
also tainted. Note that this can lead to false positives, such as taint flows
that include <code>some_obj.__class__</code>. This means that Pyre will detect all the
following flows:</p>
<pre><code class="hljs css language-python">x = some_source() <span class="hljs-comment"># 'x' is marked as tainted</span>

some_sink(x) <span class="hljs-comment"># This is detected</span>
some_sink(x.some_attribute) <span class="hljs-comment"># This is also detected</span>
some_sink(x.__class__) <span class="hljs-comment"># This is (unfortunately) also detected</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="configuration"></a><a href="#configuration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configuration</h2>
<p>Pyre uses two types of files for configuration: a single <code>taint.config</code> file,
and an unlimited number of files with a <code>.pysa</code> extension. The <code>taint.config</code>
file is a JSON document which stores definitions for Sources, Sinks, Features,
and Rules (discussed below). The <code>.pysa</code> files are stub files (elaborated on
below) which annotate your code with the Sources, Sinks, and Features defined in
your <code>taint.config</code> file. Examples of these files can be found in the <a href="https://github.com/facebook/pyre-check/tree/master/stubs/taint">pyre
repository</a>.</p>
<p>These files live in the directory configured by <code>taint_models_path</code> in your
<code>.pyre_configuration</code> file. Any <code>.pysa</code> file found in this folder will be parsed
by Pyre and the stubs will be used during the analysis.</p>
<h2><a class="anchor" aria-hidden="true" id="sources"></a><a href="#sources" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sources</h2>
<p>Sources are where tainted data originates. They are declared in your
<code>taint.config</code> file like this:</p>
<pre><code class="hljs css language-python">sources: [
    {
        name: <span class="hljs-string">"Cookies"</span>,
        comment: <span class="hljs-string">"used to annotate cookie sources"</span>
    },
]
</code></pre>
<p>Stubs that indicate what is a source are then defined in <code>.pysa</code> files. Sources
are declared in the same places that <a href="https://docs.python.org/3/library/typing.html">types are declared in Python
3</a>. Function return types,
class/model attributes, and even entire classes can be declared as sources by
adding <code>TaintSource[SOURCE_NAME]</code> wherever you would add a python type:</p>
<pre><code class="hljs css language-python"><span class="hljs-comment"># Function return source</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">django</span>.<span class="hljs-title">http</span>.<span class="hljs-title">request</span>.<span class="hljs-title">HttpRequest</span>.<span class="hljs-title">get_signed_cookie</span><span class="hljs-params">(
    self,
    key,
    default=...,
    salt=...,
    max_age=...
)</span> -&gt; TaintSource[Cookies]:</span> ...

<span class="hljs-comment"># Class attribute source:</span>
django.http.request.HttpRequest.COOKIES: TaintSource[Cookies] = ...
</code></pre>
<p>When tainting an entire class, any return from a method or access of an
attribute of the class will count as a returning tainted data. The specifics of
these stub files are discussed further in the Stubs section.</p>
<pre><code class="hljs css language-python"><span class="hljs-comment"># Class source:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseException</span><span class="hljs-params">(TaintSource[Exception])</span>:</span> ...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="sinks"></a><a href="#sinks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sinks</h2>
<p>Sinks are where tainted data terminates. They are declared in your
<code>taint.config</code> file like this:</p>
<pre><code class="hljs css language-python">sinks: [
  {
    name: <span class="hljs-string">"SQL"</span>,
    comment: <span class="hljs-string">"use to annotate places of SQL injection risk"</span>
  }
]
</code></pre>
<p>Stubs that indicate what is a sink are then defined in <code>.pysa</code> files. Sinks can
be added to the same files as sources. Sinks are declared in the same places
that <a href="https://docs.python.org/3/library/typing.html">types are declared in python
3</a>. Function parameters and even
whole classes can be declared as sinks by adding <code>TaintSink[SINK_NAME]</code> where
you would add a python type:</p>
<pre><code class="hljs css language-python"><span class="hljs-comment"># Function parameter sink</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sqlite3</span>.<span class="hljs-title">Cursor</span>.<span class="hljs-title">execute</span><span class="hljs-params">(self, sql: TaintSink[SQL], parameters)</span>:</span> ...
</code></pre>
<p>When tainting an entire class, any flow into a method or attribute of the class
will count as a flow to a taint sink. The specifics of these stub files are
discussed further in the Stubs section.</p>
<pre><code class="hljs css language-python"><span class="hljs-comment"># Entire class sink</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseException</span><span class="hljs-params">(TaintSink[Logging])</span>:</span> ...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="rules"></a><a href="#rules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rules</h2>
<p>Rules declare which flows from source to sink we are concerned about. They are
declared in your <code>taint.config</code> file like this:</p>
<pre><code class="hljs css language-python">rules: [
  {
    name: <span class="hljs-string">"SQL injection."</span>,
    code: <span class="hljs-number">1</span>,
    sources: [ <span class="hljs-string">"UserControlled"</span> ],
    sinks: [ <span class="hljs-string">"SQL"</span> ],
    message_format: <span class="hljs-string">"Data from [{$sources}] source(s) may reach [{$sinks}] sink(s)"</span>
  }
]
</code></pre>
<p>Each rule needs a brief <code>name</code> that explains its purpose and a <em>unique</em> <code>code</code>.
The rule must define a list of one or more <code>sources</code>, which we are concerned
about flowing into one or more <code>sinks</code>. <code>message_format</code> can further explain the
issue. When a flow is detected the <code>{$sources}</code> and <code>{$sinks}</code> variables will be
replaced with the name of the specific source(s) and sink(s) that were involved
in the detected flow.</p>
<h2><a class="anchor" aria-hidden="true" id="sanitizers"></a><a href="#sanitizers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sanitizers</h2>
<p>Sanitizers break a taint flow by removing taint from data. Stubs that indicate
sanitizing functions are defined in <code>.pysa</code> files. Sanitizers can be added to
the same files as sources and sinks. Functions are declared as sanitizers by
marking their return type as <code>Sanitize</code>:</p>
<pre><code class="hljs css language-python"><span class="hljs-comment"># Sanitizer function</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">django</span>.<span class="hljs-title">utils</span>.<span class="hljs-title">html</span>.<span class="hljs-title">escape</span><span class="hljs-params">(text)</span> -&gt; Sanitize:</span> ...
</code></pre>
<p>This annotation is useful in the case of explicit sanitizers such as <code>escape</code>,
which helps prevent cross site scripting (XSS) by escaping HTML characters. The
annotation is also useful, however, in cases where a function is not intended to
sanitize inputs, but is known to always return safe data despite touching
tainted data. One such example could be <code>hmac.digest(key, msg, digest)</code>, which
returns sufficiently unpredictable data that the data should no longer be
considered attacker-controlled after passing through.</p>
<p>Note that sanitizers are currently universal, meaning that they remove all taint
and can't be restricted to a specific rule or individual source to sink flows.
This means you need to ensure you aren't potentially affecting other flows when
you add a sanitizer for a flow you care about. For this reason, the above
sanitizer examples might not be a good idea to use. If you are trying to track
flows where SQL injection occurs, the <code>escape</code> sanitizer would would prevent you
from seeing any flows where data going into your SQL query happened to be html
escaped.</p>
<h2><a class="anchor" aria-hidden="true" id="taint-propagation"></a><a href="#taint-propagation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Taint Propagation</h2>
<p>Sometimes the features discussed in the Taint Analysis section are not enough to
detect all taint flows. In particular, Pyre relies on additional annotations to
help it understand when an object is tainted via a function call or when a
function call on a tainted object returns tainted data. Taint propagation is
defined by adding <code>TaintInTaintOut</code> annotations to stubs in <code>.pysa</code> files.</p>
<p>When a function call taints an object, such as when you update a dictionary with
a tainted value, Pyre needs a <code>TaintInTaintOut</code> annotation that indicates
<code>Updates[self]</code>:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict</span>.<span class="hljs-title">update</span><span class="hljs-params">(self, __m: TaintInTaintOut[Updates[self]])</span>:</span> ...
</code></pre>
<p>When a function call on a tainted object returns taint, such as when you
retrieve a value from a dictionary, Pyre needs a <code>TaintInTaintOut</code> annotation
that indicates <code>LocalReturn</code>:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict</span>.<span class="hljs-title">get</span><span class="hljs-params">(self: TaintInTaintOut[LocalReturn], key, default = ...)</span>:</span> ...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="features"></a><a href="#features" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Features</h2>
<p>Features annotations are also placed in your <code>taint.config</code> and <code>.pysa</code> files.
This is a larger topic and will be covered in detail on <a href="/docs/pyre-static-analysis-features.html">its own page</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="stub-files"></a><a href="#stub-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stub files</h2>
<h3><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>By default, Pyre computes an inferred model for each function and combines it
with any declared models in <code>.pysa</code> files (of which there can be more than one).
The union of these models and their annotations will be used. For example,
cookies are both user controlled and potentially sensitive to log, and Pyre
allows us apply two different annotations to them:</p>
<pre><code class="hljs css language-python">django.http.request.HttpRequest.COOKIES: TaintSource[UserControlled] = ...
django.http.request.HttpRequest.COOKIES: TaintSource[Cookies] = ...
</code></pre>
<p>There are other stub files with the <code>.pyi</code> extension which can also exist in
your codebase. These <code>.pyi</code> stubs are similar and use <a href="https://www.python.org/dev/peps/pep-0484/#stub-files">the same
syntax</a> as the <code>.pysa</code>
stubs, but are not the stubs that are referred to in this document (though they
are relavent to static analysis). See the &quot;Stubs&quot; section of the <a href="/docs/gradual-typing.html">Gradual Typing
page</a> for more info.</p>
<h3><a class="anchor" aria-hidden="true" id="requirements-and-features"></a><a href="#requirements-and-features" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requirements and Features</h3>
<h4><a class="anchor" aria-hidden="true" id="fully-qualified-names"></a><a href="#fully-qualified-names" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fully qualified names</h4>
<p>Any declarations in <code>.pysa</code> files must use the fully qualified name for the
function/attribute they are attempting to annotate. You can usually find the
fully qualified name for a type by looking at how it is imported, however, it's
important to note that fully qualified names correspond to where something is
declared, not necessarily where it is imported from. For example, you can import
<code>HttpRequest</code> directly from the <code>django.http</code> module, even though it is defined in
<code>django.http.request</code>. If you wanted to taint an attribute of <code>HttpRequest</code>,
you would need to use the module in which it was defined:</p>
<pre><code class="hljs css language-python">django.http.request.HttpRequest.GET: TaintSource[UserControlled] = ...
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="exact-signatures"></a><a href="#exact-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exact Signatures</h4>
<p>The signatures of any stub functions need to exactly match the the signature of
the function definition. This means that all parameters, including optional
parameters, <code>*args</code>, and <code>**kwargs</code> must be present. The default value of
optional parameters, however, can be elided (see below). Additionally, if a
function includes an asterisk that indicates <a href="https://www.python.org/dev/peps/pep-3102/">keyword only
arguments</a>, then that should be
present too. So for example, <code>urllib.request.urlopen</code> has the following
signature:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">urlopen</span><span class="hljs-params">(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, *, cafile=None,
            capath=None, cadefault=False, context=None)</span>:</span>
</code></pre>
<p>That function would be annotated like this:</p>
<pre><code class="hljs css language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">urllib</span>.<span class="hljs-title">request</span>.<span class="hljs-title">urlopen</span><span class="hljs-params">(url: TaintSink[RequestSend], data = ...,
                           timeout = ..., *, cafile = ..., capath = ...,
                           cadefault = ..., context = ...)</span>:</span> ...
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="eliding"></a><a href="#eliding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eliding</h4>
<p>As you can see from the above examples, defaulted values and function bodies can
both be elided with <code>...</code>. Additionally, type annotations <em>must</em> be entirely
omitted (not replaced with <code>...</code>), even when present on the declaration of the
function. This is done to make parsing taint annotations unambiguous.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/querying-pyre.html"><span class="arrow-prev">← </span><span>Querying Pyre</span></a><a class="docs-next button" href="/docs/pyre-static-analysis-running.html"><span>Running Pyre Static Analyzer</span><span class="arrow-next"> →</span></a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><a href="https://code.facebook.com/projects/" target="_blank">Open Source Projects</a><a href="https://github.com/facebook/" target="_blank">Github</a><a href="https://twitter.com/fbOpenSource" target="_blank">Twitter</a><a href="https://github.com/facebook/pyre-check" target="_blank">Contribute to Pyre</a></section></footer></div></body></html>