<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pyre Errors · Pyre</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Elaboration on some categories of errors thrown by Pyre.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Pyre Errors · Pyre"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pyre-check.org/index.html"/><meta property="og:description" content="&lt;p&gt;Elaboration on some categories of errors thrown by Pyre.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/integrated_logo_light.png" alt="Pyre"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/installation.html" target="_self">Getting Started</a></li><li class="siteNavGroupActive"><a href="/docs/overview.html" target="_self">Documentation</a></li><li class=""><a href="https://github.com/facebook/pyre-check" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Contents</span></h2></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Contents</h3><ul><li class="navListItem"><a class="navItem" href="/docs/overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/installation.html">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/guided-tour.html">Guided Tour</a></li><li class="navListItem"><a class="navItem" href="/docs/configuration.html">Configuring Pyre</a></li><li class="navListItem"><a class="navItem" href="/docs/gradual-typing.html">Gradual Typing</a></li><li class="navListItem"><a class="navItem" href="/docs/error-suppression.html">Error Suppression</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/error-types.html">Error Types</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-integration.html">Editor Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/watchman-integration.html">Watchman Integration</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Pyre Errors</h1></header><article><div><span><p>Elaboration on some categories of errors thrown by Pyre.</p>
<h2><a class="anchor" aria-hidden="true" id="pyre-error-9-incompatible-variable-type"></a><a href="#pyre-error-9-incompatible-variable-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pyre Error [9]: Incompatible Variable Type</h2>
<p>Pyre will error when assigning incompatible types to local variables and parameters that were explicitly annotated.</p>
<p>That is, the following will error:</p>
<pre><code class="hljs">def f(x: int) -&gt; None:
  x = <span class="hljs-string">""</span> # Incompatible variable<span class="hljs-built_in"> type </span><span class="hljs-builtin-name">error</span>
  y: int = 1
  y = <span class="hljs-string">""</span> # Incompatible variable<span class="hljs-built_in"> type </span><span class="hljs-builtin-name">error</span>
</code></pre>
<p>The rationale here is that it's surprising for an explicitly annotated variable to have an
incompatible type later on in the same function.</p>
<p>If you intended to change the type of the variable, you can explicitly annotate it with the new type:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
  x: str = <span class="hljs-string">""</span> <span class="hljs-comment"># No errors!</span>
  y: int = <span class="hljs-number">1</span>
  y: str = <span class="hljs-string">""</span> <span class="hljs-comment"># No errors!</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="pyre-errors-14-15-behavioral-subtyping"></a><a href="#pyre-errors-14-15-behavioral-subtyping" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pyre Errors [14/15]: Behavioral Subtyping</h2>
<p>Method overrides should follow
<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov's substitution principle</a>.
In short, parameter types can't be more restrictive and return types
can't be more permissive in overridden methods. To see why, consider the following example:</p>
<pre><code class="hljs">  def <span class="hljs-built_in">width</span>(<span class="hljs-built_in">image</span>: Image) -&gt; <span class="hljs-keyword">float</span>:
    <span class="hljs-built_in">return</span> <span class="hljs-built_in">image</span>.<span class="hljs-built_in">width</span>()
</code></pre>
<p>Say we now have different implementations of our <code>Image</code> class, one of which
violates the substitution principle:</p>
<pre><code class="hljs">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span>:</span>
<span class="hljs-meta">    @abstractmethod:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> -&gt; float:</span> <span class="hljs-keyword">pass</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpegImage</span><span class="hljs-params">(Image)</span>:</span>
<span class="hljs-meta">    @override</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> -&gt; int:</span> <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>  <span class="hljs-comment"># this is fine</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexImage</span><span class="hljs-params">(Image)</span>:</span>
<span class="hljs-meta">    @override</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> -&gt; complex:</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1j</span>
</code></pre>
<p>Clearly our <code>width</code> function above breaks when used with a <code>ComplexImage</code> instance.
The case for parameters follows analogously.</p>
<h2><a class="anchor" aria-hidden="true" id="pyre-errors-16-missing-attributes"></a><a href="#pyre-errors-16-missing-attributes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pyre Errors [16]: Missing Attributes</h2>
<p>Your code is most likely trying to access an attribute that Pyre does not know about.
Pyre has various ways of inferring what is an attribute of an object:</p>
<h3><a class="anchor" aria-hidden="true" id="explicitly-declared"></a><a href="#explicitly-declared" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Explicitly Declared</h3>
<pre><code class="hljs">  class Derp:
    <span class="hljs-keyword">attribute</span>: int = <span class="hljs-number">1</span>

    @<span class="hljs-keyword">property</span><span class="hljs-title">
    </span>def <span class="hljs-keyword">property</span><span class="hljs-title"></span>(self) -&gt; int: ...
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="implicitly-declared"></a><a href="#implicitly-declared" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implicitly Declared</h3>
<pre><code class="hljs">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derp</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
       <span class="hljs-keyword">self</span>.<span class="hljs-symbol">attribute:</span> int = <span class="hljs-number">1</span>
</code></pre>
<p>Pyre does one level of inlining to infer implicit parameters
We suggest you do not heavily rely on this feature as it is not sound and makes our code brittle.
Support for this is temporary.</p>
<h2><a class="anchor" aria-hidden="true" id="pyre-errors-18-21-undefined-name-undefined-import"></a><a href="#pyre-errors-18-21-undefined-name-undefined-import" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pyre Errors [18/21]: Undefined Name, Undefined Import</h2>
<p>Error 18 (&quot;Undefined name&quot;) is raised when your code tries to access a variable or function that Pyre could not resolve.
This is usually caused by failing to import the proper module.</p>
<pre><code class="hljs">  # <span class="hljs-symbol">'import</span> some_module' <span class="hljs-keyword">is</span> missing
  some_module.some_func()
</code></pre>
<p>Pyre will raise error 21 instead (&quot;Undefined import&quot;) when the import statement is present, but the module to be imported could not be found in the search path.
If the module provides stub files, please provide their location via the <code>--search-path</code> commandline parameter.</p>
<h2><a class="anchor" aria-hidden="true" id="list-and-dictionary-mismatches-with-subclassing"></a><a href="#list-and-dictionary-mismatches-with-subclassing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List and Dictionary Mismatches With Subclassing</h2>
<p>Pyre will error when, for instance, a <code>List[int]</code> is passed in when a <code>List[float]</code> is expected, as in the following example:</p>
<pre><code class="hljs">def to_seconds(milliseconds: <span class="hljs-keyword">List</span>[<span class="hljs-keyword">float</span>]) -&gt; <span class="hljs-keyword">List</span>[<span class="hljs-keyword">int</span>]:
  <span class="hljs-keyword">return</span> [<span class="hljs-keyword">int</span>(x/<span class="hljs-number">1000.0</span>) <span class="hljs-keyword">for</span> x in milliseconds]

my_list: <span class="hljs-keyword">List</span>[<span class="hljs-keyword">int</span>] = [<span class="hljs-number">1</span>]
my_list = to_seconds(my_list) <span class="hljs-comment"># Pyre errors here!</span>
</code></pre>
<p>This code is fine at runtime, so it might be surprising that Pyre errors here. However, consider the following code:</p>
<pre><code class="hljs">def halve<span class="hljs-constructor">_first_element(<span class="hljs-params">list</span>: List[<span class="hljs-params">float</span>])</span> -&gt; None:
  <span class="hljs-built_in">list</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span> /= <span class="hljs-number">2</span>

my_list: List<span class="hljs-literal">[<span class="hljs-identifier">int</span>]</span> = <span class="hljs-literal">[<span class="hljs-number">1</span>]</span>
halve<span class="hljs-constructor">_first_element(<span class="hljs-params">my_list</span>)</span>
<span class="hljs-keyword">function</span><span class="hljs-constructor">_taking_int(<span class="hljs-params">my_list</span>[0])</span> # Oh no, my_list<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> is <span class="hljs-number">0.5</span>!
</code></pre>
<p>If we allowed passing in <code>my_list</code> to the <code>halve_first_element</code> function here, the above code would type check. It's perfectly valid from the perspective of the callee to modify the list's element to be a float, as it was annotated as taking a list of floats, but because this list escapes the scope of the callee, we can't allow this in the type checker.</p>
<p>To work around this, we can signal to the type checker that the parameter can't be modified. Here's how you can tell the type checker that you won't change the container in your function:</p>
<pre><code class="hljs"><span class="hljs-comment"># I can't modify milliseconds here, so it's safe to pass a Iterable[int].</span>
def to_seconds(milliseconds: Iterable[float]) -&gt; List[int]:
  return [int(x/1000.0) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> milliseconds]

my_list: List[int] = [1]
my_list = to_seconds(my_list) #<span class="hljs-built_in"> Type </span>checks!
</code></pre>
<p><code>typing.Iterable</code> is an immutable variant for lists that allows accessing the list without modifying it. Most commonly used generic containers have immutable variants, and I would encourage you to use them for function parameters whenever you don't need to modify a container in your function.
Here are some immutable variants for commonly used containers:</p>
<pre><code class="hljs">typing<span class="hljs-selector-class">.List</span> → typing<span class="hljs-selector-class">.Iterable</span>
typing<span class="hljs-selector-class">.Dict</span> → typing<span class="hljs-selector-class">.Mapping</span>
typing<span class="hljs-selector-class">.Set</span> → typing<span class="hljs-selector-class">.AbstractSet</span>
</code></pre>
<p>Invariance, combined with type inference, comes with a few gotchas. When you write an expression, Pyre infers the most precise type possible. For instance, Pyre infers the <code>List[int]</code> type for <code>[1, 2]</code>, even though <code>List[float]</code> would be a perfectly valid type here. This can cause issues, as in the following example:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zeroes</span><span class="hljs-params">(number_of_elements: int)</span> -&gt; List[float]:</span>
  a = [<span class="hljs-number">0</span>] * number_of_elements
  <span class="hljs-keyword">return</span> a <span class="hljs-comment"># Pyre errors here!</span>
</code></pre>
<p>What happened above is that Pyre inferred a type of <code>List[int]</code> for a, and invariance kicked in. You can work around this by adding an explicit annotation when declaring a:</p>
<pre><code class="hljs">def zeroes(number_of_elements: int) -&gt; List[float]:
  a: List[float] = [0] * number_of_elements
  return a #<span class="hljs-built_in"> Type </span>checks!
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/error-suppression.html"><span class="arrow-prev">← </span><span>Error Suppression</span></a><a class="docs-next button" href="/docs/lsp-integration.html"><span>Editor Integration</span><span class="arrow-next"> →</span></a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><a href="https://code.facebook.com/projects/" target="_blank">Open Source Projects</a><a href="https://github.com/facebook/" target="_blank">Github</a><a href="https://twitter.com/fbOpenSource" target="_blank">Twitter</a><a href="https://github.com/facebook/pyre-check" target="_blank">Contribute to Pyre</a></section></footer></div></body></html>