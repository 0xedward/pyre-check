(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open Ast
open Analysis
open Pyre

module Scheduler = ServiceScheduler
module Ignore = ServiceIgnore


type analysis_results = {
  errors: Error.t list;
  number_files: int;
  coverage: Coverage.t;
}


let analyze_source
    ({ Configuration.infer; _ } as configuration)
    environment
    ({ Source.path; metadata; _ } as source) =
  (* Override file-specific local debug configuraiton *)
  let { Source.Metadata.autogenerated; local_mode; debug; version; number_of_lines; _ } =
    metadata
  in
  let local_strict, declare =
    match local_mode with
    | Source.Strict -> true, false
    | Source.Declare -> false, true
    | _ -> false, false
  in
  let configuration =
    Configuration.localize
      configuration
      ~local_debug:debug
      ~local_strict
      ~declare
  in

  if version < 3 || autogenerated then
    begin
      Log.log
        ~section:`Check
        "Skipping `%s` (%s)"
        path
        (if autogenerated then "auto-generated" else "Python 2.x");
      {
        TypeCheck.Result.errors = [];
        coverage = Coverage.create ();
      }
    end
  else
    begin
      let timer = Timer.start () in
      Log.log ~section:`Check "Checking `%s`..." path;
      let result =
        let check = if infer then Inference.infer else TypeCheck.check in
        check configuration environment source
      in
      Statistics.performance
        ~flush:false
        ~randomly_log_every:100
        ~section:`Check
        ~name:(Format.asprintf "SingleFileTypeCheck of %s" path)
        ~timer
        ~normals:["path", path; "request kind", "SingleFileTypeCheck"]
        ~integers:["number of lines", number_of_lines]
        ();
      result
    end


let analyze_sources_parallel scheduler configuration environment handles =
  let timer = Timer.start () in
  let init = {
    errors = [];
    number_files = 0;
    coverage = Coverage.create ();
  }
  in
  let { errors; coverage; _ } =
    Scheduler.map_reduce
      scheduler
      ~configuration
      handles
      ~bucket_size:75
      ~init:
        {
          errors = [];
          number_files = 0;
          coverage = Coverage.create ();
        }
      ~map:(fun _ handles ->
          Annotated.Class.AttributesCache.clear ();
          let result =
            List.fold ~init ~f:(
              fun {
                errors;
                number_files;
                coverage = total_coverage;
              }
                handle ->
                match AstSharedMemory.get_source handle with
                | Some source ->
                    let {
                      TypeCheck.Result.errors = new_errors;
                      coverage;
                      _;
                    } =
                      analyze_source configuration environment source
                    in
                    {
                      errors = List.append new_errors errors;
                      number_files = number_files + 1;
                      coverage = Coverage.sum total_coverage coverage;
                    }
                | None -> {
                    errors;
                    number_files = number_files + 1;
                    coverage = total_coverage;
                  })
              handles
          in
          Statistics.flush ();
          result)
      ~reduce:(fun left right ->
          let number_files = left.number_files + right.number_files in
          Log.log
            ~section:`Progress
            "Processed %d of %d sources"
            number_files
            (List.length handles);
          {
            errors = List.append left.errors right.errors;
            number_files;
            coverage = Coverage.sum left.coverage right.coverage;
          })
  in
  Statistics.performance ~name:"analyzed sources" ~timer ();
  Ignore.postprocess handles errors, coverage


let analyze_sources
    scheduler
    ({ Configuration.local_root; project_root; filter_directories; _ } as configuration)
    environment
    handles =
  Log.info "Checking...";

  Annotated.Class.AttributesCache.clear ();
  let handles =
    let filter_by_directories path =
      match filter_directories with
      | None ->
          true
      | Some filter_directories ->
          List.exists
            filter_directories
            ~f:(fun directory -> Path.directory_contains ~follow_symlinks:true ~directory path)
    in
    let filter_by_root handle =
      match AstSharedMemory.get_source handle with
      | Some { Source.path; _ } ->
          let relative = Path.create_relative ~root:local_root ~relative:path in
          Path.directory_contains relative ~follow_symlinks:true ~directory:project_root &&
          filter_by_directories relative
      | _ ->
          false
    in
    List.filter handles ~f:filter_by_root
  in
  if Scheduler.is_parallel scheduler then
    analyze_sources_parallel scheduler configuration environment handles
  else
    let sources = List.filter_map ~f:AstSharedMemory.get_source handles in
    let analyze_and_postprocess
        configuration
        (current_errors, total_coverage)
        source =
      let { TypeCheck.Result.errors; coverage; _ } =
        analyze_source configuration environment source
      in
      errors :: current_errors,
      Coverage.sum total_coverage coverage
    in
    let errors, coverage =
      List.fold
        ~init:([], Coverage.create ())
        ~f:(analyze_and_postprocess configuration)
        sources
    in
    let errors =
      List.concat errors
      |> Ignore.postprocess handles
    in
    errors, coverage
