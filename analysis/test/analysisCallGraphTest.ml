(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core
open OUnit2

open Analysis
open Ast
open Statement
open TypeCheck

open Test

module Parallel = Hack_parallel.Std
module TestSetup = AnalysisTestSetup


let test_create _ =
  let call_graph = CallGraph.create () in
  let (module Handler: CallGraph.Handler) = CallGraph.handler call_graph in

  Handler.register_overload ~access:(Access.create "one") ~overload:(Access.create "one");
  Handler.register_overload ~access:(Access.create "one") ~overload:(Access.create "two");
  Handler.register_overload ~access:(Access.create "two") ~overload:(Access.create "three");

  let overloads = call_graph.CallGraph.overloads in
  assert_equal 2 (Access.Table.length overloads)


let parse_source ?(qualifier=[]) source =
  let source =
    let metadata =
      Source.Metadata.create
        ~autogenerated:false
        ~debug:true
        ~declare:false
        ~ignore_lines:[]
        ~strict:false
        ~version:3
        ~number_of_lines:(-1)
        ()
    in
    parse ~qualifier source
    |> (fun source -> { source with Source.metadata })
    |> Preprocessing.preprocess
  in
  source


let check_source ?call_graph source =
  let configuration =
    Configuration.create
      ~debug:true
      ~strict:false
      ~declare:false
      ~infer:false
      ()
  in
  let environment = TestSetup.environment ~configuration () in
  Environment.populate ~configuration environment [source];
  check configuration environment call_graph source |> ignore


let assert_call_graph source ~expected =
  let source = parse_source source in
  let configuration =
    Configuration.create ~debug:true ~strict:false ~declare:false ~infer:false ()
  in
  let environment = TestSetup.environment ~configuration () in
  Environment.populate ~configuration environment [source];
  check configuration environment None source |> ignore;
  let make_resolution define annotations =
    Environment.resolution
      environment
      ~annotations
      ~define
      ()
  in
  let call_graph =
    let open TypeResolutionSharedMemory.TypeAnnotationsValue in
    let fold_defines
        call_graph
        { Node.value = ({ Define.name = caller; _ } as define); _ } =
      let cfg = Cfg.create define in
      let annotation_lookup =
        let fold_annotations map { key; annotations } =
          Int.Map.set map ~key ~data:annotations
        in
        TypeResolutionSharedMemory.get caller
        |> (fun value -> Option.value_exn value)
        |> List.fold ~init:Int.Map.empty ~f:fold_annotations
      in
      let fold_cfg ~key:node_id ~data:node call_graph =
        let statements = Cfg.Node.statements node in
        let fold_statements statement_index call_graph statement =
          let annotations =
            Int.Map.find_exn
              annotation_lookup
              ([%hash: int * int] (node_id, statement_index))
            |> Access.Map.of_alist_exn
          in
          let resolution = make_resolution define annotations in
          let fold_accesses call_graph { Node.value = access; _ } =
            let add_call_edge call_graph ~resolution:_ ~resolved ~element:_ =
              let open Annotation.Type in
              let open Record.Callable in
              match Annotation.annotation resolved with
              | Callable { kind = Callable.Named callee; _ } ->
                  Access.Map.set call_graph ~key:caller ~data:callee
              | _ ->
                  call_graph
            in
            Annotated.Access.create access
            |> Annotated.Access.fold ~resolution ~initial:call_graph ~f:add_call_edge
          in
          Visit.collect_accesses_with_location statement
          |> List.fold ~init:call_graph ~f:fold_accesses
        in
        List.foldi statements ~init:call_graph ~f:fold_statements
      in
      Hashtbl.fold cfg ~init:call_graph ~f:fold_cfg
    in
    Preprocessing.defines source
    |> List.fold ~init:Access.Map.empty ~f:fold_defines
  in
  let result =
    let fold_call_graph ~key:caller ~data:callee result =
      Format.sprintf
        "%s -> %s\n%s"
        (Access.show caller)
        (Access.show callee)
        result
    in
    Access.Map.fold call_graph ~init:"" ~f:fold_call_graph
  in
  let expected = expected ^ "\n" in
  assert_equal ~printer:ident result expected


let test_construction _ =
  assert_call_graph
    {|
    class Foo:
      def __init__(self):
        pass

      def bar(self):
        return 10

      def quux(self):
        return self.bar()
    |}
    ~expected:"Foo.quux -> Foo.bar";

  assert_call_graph
    {|
    class Foo:
      def __init__(self):
        pass

      def bar(self):
        return self.quux()

      def quux(self):
        return self.bar()
    |}
    ~expected:
      "Foo.quux -> Foo.bar\n\
       Foo.bar -> Foo.quux"


let test_type_collection _ =
  let open TypeResolutionSharedMemory in
  let open TypeAnnotationsValue in
  let (!) = Access.show in
  let assert_type_collection source ~qualifier ~expected =
    let source = parse_source ~qualifier source in
    let configuration =
      Configuration.create
        ~debug:true
        ~strict:false
        ~declare:false
        ~infer:false
        ()
    in
    let environment = TestSetup.environment ~configuration () in
    Environment.populate ~configuration environment [source];
    check configuration environment None source |> ignore;
    let defines =
      Preprocessing.defines source
      |> List.map ~f:(fun define -> define.Node.value)
    in
    let Define.{ name; body = statements; _ } as define = List.nth_exn defines 1 in
    let lookup =
      let build_lookup lookup { key; annotations } =
        Int.Map.set lookup ~key ~data:annotations in
      TypeResolutionSharedMemory.get name
      |> (fun value -> Option.value_exn value)
      |> List.fold ~init:Int.Map.empty ~f:build_lookup
    in
    let test_expect (node_id, statement_index, test_access, expected_type) =
      let key = [%hash: int * int] (node_id, statement_index) in
      let test_access = Access.create test_access in
      let annotations =
        Int.Map.find_exn lookup key
        |> Access.Map.of_alist_exn
      in
      let resolution = Environment.resolution environment ~annotations ~define () in
      let statement = List.nth_exn statements statement_index in
      Visit.collect_accesses_with_location statement
      |> List.hd_exn
      |> fun { Node.value = access; _ } ->
      if String.equal !access !test_access then
        let open Annotated in
        let open Access.Element in
        let last_element =
          Annotated.Access.create access
          |>  Annotated.Access.last_element ~resolution
        in
        match last_element with
        | Signature {
            signature =
              Signature.Found {
                Signature.callable = {
                  Type.Callable.kind = Type.Callable.Named callable_type;
                  _;
                };
                _;
              };
            _;
          } ->
            assert_equal ~printer:ident !callable_type expected_type
        | _ ->
            assert false
    in
    List.iter expected ~f:test_expect

  in
  assert_type_collection
    {|
        class A:
          def foo(self) -> int:
            return 1

        class B:
          def foo(self) -> int:
            return 2

        class X:
          def caller(self):
            a = A()
            a.foo()
            a = B()
            a.foo()
        |}
    ~qualifier:(Access.create "test1")
    ~expected:
      [
        (5, 1, "$local_0_a.foo.(...)", "test1.A.foo");
        (5, 3, "$local_0_a.foo.(...)", "test1.B.foo")
      ];

  assert_type_collection
    {|
       class A:
         def foo(self) -> int:
           return 1

       class B:
         def foo(self) -> A:
           return A()

       class X:
         def caller(self):
           a = B().foo().foo()
    |}
    ~qualifier:(Access.create "test2")
    ~expected:[(5, 0, "$local_0_a.foo.(...).foo.(...)", "test2.A.foo")]


let () =
  Parallel.Daemon.check_entry_point ();
  "callGraph">:::[
    "create">::test_create;
    "type_collection">::test_type_collection;
    "build">::test_construction;
  ]
  |> run_test_tt_main
