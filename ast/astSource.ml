(** Copyright (c) 2016-present, Facebook, Inc.

    This source code is licensed under the MIT license found in the
    LICENSE file in the root directory of this source tree. *)

open Core

open AstExpression

module Ignore = AstIgnore
module Location = AstLocation
module Statement = AstStatement


type mode =
  | Default
  | Declare
  | Strict
  | Infer
[@@deriving compare, eq, show, sexp, hash]


module Metadata = struct

  type t = {
    autogenerated: bool;
    debug: bool;
    local_mode: mode;
    ignore_lines: Ignore.t list;
    number_of_lines: int;
    version: int;
  }
  [@@deriving compare, eq, show]

  let create
      ?(autogenerated = false)
      ?(debug = true)
      ?(declare = false)
      ?(ignore_lines = [])
      ?(strict = false)
      ?(version = 3)
      ~number_of_lines
      () =
    let local_mode =
      if declare then
        Declare
      else if strict then
        Strict
      else
        Default
    in
    {
      autogenerated;
      debug;
      local_mode;
      ignore_lines;
      number_of_lines;
      version;
    }

  let parse path lines =
    let is_python_2_shebang line =
      String.is_prefix ~prefix:"#!" line &&
      String.is_substring ~substring:"python2" line
    in
    let is_pyre_comment comment_substring line =
      String.is_prefix ~prefix:"#" line &&
      String.is_substring ~substring:comment_substring line
    in
    let is_debug = is_pyre_comment "pyre-debug" in
    let is_strict = is_pyre_comment "pyre-strict" in
    let is_declare = is_pyre_comment "pyre-do-not-check" in
    let parse_ignore index line ignored_lines =
      let create_ignore ~index ~line ~kind =
        let codes =
          try
            Str.search_forward
              (Str.regexp "pyre-\\(ignore\\|fixme\\)\\[\\([0-9, ]+\\)\\]")
              line
              0
            |> ignore;
            Str.matched_group 2 line
            |> Str.split (Str.regexp "[^0-9]+")
            |> List.map ~f:Int.of_string
          with Not_found -> []
        in
        let ignored_line =
          if String.is_prefix ~prefix:"#" (String.strip line) then
            index + 2
          else
            index + 1
        in
        let location =
          let start_column =
            Str.search_forward (Str.regexp "\\(pyre-\\(ignore\\|fixme\\)\\|type: ignore\\)") line 0
          in
          let end_column = String.length line in
          let start = { Location.line = index + 1; column = start_column } in
          let stop = { Location.line = index + 1; column = end_column } in
          { Location.path; start; stop }
        in
        Ignore.create ~ignored_line ~codes ~location ~kind
      in
      if String.is_substring ~substring:"pyre-ignore" line then
        (create_ignore ~index ~line ~kind:Ignore.PyreIgnore) :: ignored_lines
      else if String.is_substring ~substring:"pyre-fixme" line then
        (create_ignore ~index ~line ~kind:Ignore.PyreFixme) :: ignored_lines
      else if String.is_substring ~substring:"type: ignore" line then
        (create_ignore ~index ~line ~kind:Ignore.TypeIgnore) :: ignored_lines
      else
        ignored_lines
    in
    let is_autogenerated line =
      String.is_substring ~substring:("@" ^ "generated") line ||
      String.is_substring ~substring:("@" ^ "auto-generated") line
    in

    let collect
        index
        (version, debug, strict, declare, ignored_lines, autogenerated)
        line =
      let version =
        match version with
        | Some _ ->
            version
        | None ->
            if is_python_2_shebang line then Some 2 else None in
      version,
      debug || is_debug line,
      strict || is_strict line,
      declare || is_declare line,
      parse_ignore index line ignored_lines,
      autogenerated || is_autogenerated line
    in
    let version, debug, strict, declare, ignore_lines, autogenerated =
      List.map ~f:(fun line -> String.strip line |> String.lowercase) lines
      |> List.foldi ~init:(None, false, false, false, [], false) ~f:collect
    in
    let local_mode =
      if declare then
        Declare
      else if strict then
        Strict
      else
        Default
    in
    {
      autogenerated;
      debug;
      local_mode;
      ignore_lines;
      number_of_lines = List.length lines;
      version = Option.value ~default:3 version;
    }
end


type t = {
  docstring: string option;
  metadata: Metadata.t;
  path: string;
  qualifier: Access.t;
  statements: Statement.t list;
}
[@@deriving compare, eq, show]


let mode source ~configuration =
  match configuration, source with
  | { Configuration.infer = true; _ }, _ ->
      Infer

  | { Configuration.strict = true; _ }, _
  | _, { metadata = { Metadata.local_mode = Strict; _ }; _ } ->
      Strict

  | { Configuration.declare = true; _ }, _
  | _, { metadata = { Metadata.local_mode = Declare; _ }; _ } ->
      Declare

  | _ ->
      Default


let create
    ?(docstring = None)
    ?(metadata = Metadata.create ~number_of_lines:(-1) ())
    ?(path = "")
    ?(qualifier = [])
    statements =
  {
    docstring;
    metadata;
    path;
    qualifier;
    statements;
  }


let ignore_lines { metadata = { Metadata.ignore_lines; _ }; _ } =
  ignore_lines


let statements { statements; _ } =
  statements


let qualifier ~path =
  let reversed_elements =
    Filename.parts path
    |> List.tl_exn (* Strip current directory. *)
    |> List.rev in
  let last_without_suffix =
    let last = List.hd_exn reversed_elements in
    match String.rindex last '.' with
    | Some index ->
        String.slice last 0 index
    | _ ->
        last in
  let strip = function
    | "builtins" :: tail ->
        tail
    | "__init__" :: tail ->
        tail
    | elements ->
        elements in
  (last_without_suffix :: (List.tl_exn reversed_elements))
  |> strip
  |> List.rev_map
    ~f:Access.create
  |> List.concat


let expand_relative_import { qualifier; path; _ } ~from =
  (* Expand relative imports according to PEP 328 *)
  let dots, postfix =
    let is_dot = function
      | Access.Identifier identifier when Identifier.show identifier = "" -> true
      | _ -> false
    in
    List.split_while ~f:is_dot from
  in
  let prefix =
    if not (List.is_empty dots) then
      let drop =
        let drop =
          if List.length dots = 2 && List.length postfix = 0 then
            (* Special case for single `.` in from clause. *)
            1
          else
            List.length dots
        in
        let is_initializer_module =
          String.is_suffix path ~suffix:"/__init__.py" ||
          String.is_suffix path ~suffix:"/__init__.pyi"
        in
        if is_initializer_module then
          drop - 1
        else
          drop
      in
      List.rev qualifier
      |> (fun reversed -> List.drop reversed drop)
      |> List.rev
    else
      []
  in
  prefix @ postfix
